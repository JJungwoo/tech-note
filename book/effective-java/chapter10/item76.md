# 가능한 한 실패 원자적으로 만들라

프로그램에 대해 예외처리를 할 때 가능한 작업을 멈추지 않고 검사 예외를 던진 후에 호출자가 오류 상태를 복구할 수 있는 것이 가장 좋다.
<br>
이를 메서드가 **실패 원자적인** 특성을 갖는다고 한다.

>**실패 원자적(failure-atomic)** : 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지하는 것

### 메서드를 실패 원자적으로 만드는 방법

- 불변 객체(아이템 17)로 설계하는 것
  - 불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않는다.
- 작업 수행에 앞서 매개변수의 유효성을 검사하는 것(아이템 49) 
  - 객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있다.  
  - Stack.pop 메서드 예시
  ```java
  public Object pop() {
      if(size == 0){
          throw new EmptyStackException();
      }
      Object result = elements[--size];
      elements[size] = null // 다쓴 참조 해제
      return result;
  }
  ```
- 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법
- 객체의 임시 복사본에서 작업을 수행한 다음 작업이 성공적으로 완료되면 원래 객체와 교체하는 것
- 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법

### 실패 원자성을 만족 할 수 없는 경우

- 하나의 객체를 두 스레드가 동기화 없이 접근 했을 때
  - 두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 그 객체의 일관성이 깨질 수 있다. 이때 ConcurrentModificationException을 잡아냈다고 해서 그 객체가 여전히 사용할 수 있는 상태가 아닐 수 있다.
- Error는 복구할 수 없으므로 AssertionError에 대해서는 실패 원자적으로 만들 시도조차 할 필요 없다.

### 항상 실패 원자성을 시도할 필요 없다

- 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산에 대해서는 여러가지를 고려해봐야 한다. 
  - 최대한 최소 비용으로 실패 원자성을 만족하게 만들자
- 메서드 명시를 통해 실패 시의 객체 상태를 API 설명에 명시해야 한다.
  - 메서드 명세에 기술한 예외라면 설혹 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다.

# 핵심 정리
- 메서드를 작성할 때는 가능한 실패 원자성을 고려하자
